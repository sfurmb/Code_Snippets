<!DOCTYPE html>
<html>

<head>
    <title>Python Reference</title>
    <link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
</head>

<body>
    <pre class="prettyprint id=" quine " style="border:2px solid #88c ">
<p>'''<br />Table of Contents:<br /> Imports<br /> Data Types<br /> Math<br /> Comparisons and Boolean Operations<br /> Conditional Statements<br /> Lists<br /> Tuples<br /> Strings<br /> Dictionaries<br /> Sets<br /> Defining Functions<br /> Anonymous (Lambda) Functions<br /> For Loops and While Loops<br /> Comprehensions<br /> Map, Reduce, Filter<br />'''</p>
<p>### IMPORTS ###<br /># 'generic import' of math module<br />from __future__ import division</p>
<p>import math<br />math.sqrt(25)</p>
<p># import a function<br />from math import sqrt<br />sqrt(25) # no longer have to reference the module</p>
<p># import multiple functions at once<br />from math import cos, floor</p>
<p># import all functions in a module (generally discouraged)<br />from os import *</p>
<p># define an alias<br />import numpy as np</p>
<p># show all functions in math module<br />dir(math)</p>
<p><br />### DATA TYPES ###<br /># determine the type of an object<br />type(2) # returns 'int'<br />type(2.0) # returns 'float'<br />type('two') # returns 'str'<br />type(True) # returns 'bool'<br />type(None) # returns 'NoneType'</p>
<p># check if an object is of a given type<br />isinstance(2.0, int) # returns False<br />isinstance(2.0, (int, float)) # returns True</p>
<p># convert an object to a given type<br />float(2)<br />int(2.9)<br />str(2.9)</p>
<p># zero, None, and empty containers are converted to False<br />bool(0)<br />bool(None)<br />bool('') # empty string<br />bool([]) # empty list<br />bool({}) # empty dictionary</p>
<p># non-empty containers and non-zeros are converted to True<br />bool(2)<br />bool('two')<br />bool([2])</p>
<p>### MATH ###<br /># basic operations<br />10 + 4 # add (returns 14)<br />10 - 4 # subtract (returns 6)<br />10 * 4 # multiply (returns 40)<br />10 ** 4 # exponent (returns 10000)<br />10 / 4 # divide (returns 2 because both types are 'int')<br />10 / float(4) # divide (returns 2.5)<br />5 % 4 # modulo (returns 1) - also known as the remainder</p>
<p># force '/' in Python 2.x to perform 'true division' (unnecessary in Python 3.x)<br />10 / 4 # true division (returns 2.5)<br />10 // 4 # floor division (returns 2)</p>
<p>### COMPARISONS AND BOOLEAN OPERATIONS ###<br /># comparisons (these return True)<br />5 &gt; 3<br />5 &gt;= 3<br />5 != 3<br />5 == 5</p>
<p># boolean operations (these return True)<br />5 &gt; 3 and 6 &gt; 3<br />5 &gt; 3 or 5 &lt; 3<br />not False<br />False or not False and True # evaluation order: not, and, or</p>
<p><br />### CONDITIONAL STATEMENTS ###<br />x = 10<br /># if statement<br />if x &gt; 0:<br /> print 'positive'</p>
<p># if/else statement<br />if x &gt; 0:<br /> print 'positive'<br />else:<br /> print 'zero or negative'</p>
<p>x = 10<br /># if/elif/else statement<br />if x &gt; 0:<br /> print 'positive'<br />elif x == 0:<br /> print 'zero'<br />else:<br /> print 'negative'</p>
<p># single-line if statement (sometimes discouraged)<br />if x &gt; 0: print 'positive'</p>
<p># single-line if/else statement (sometimes discouraged)<br /># known as a 'ternary operator'<br />'positive' if x &gt; 0 else 'zero or negative'</p>
<p><br />### LISTS ###<br />## properties: ordered, iterable, mutable, can contain multiple data types<br /># create an empty list (two ways)<br />empty_list = []<br />empty_list = list()</p>
<p># create a list<br />simpsons = ['homer', 'marge', 'bart']</p>
<p># examine a list<br />simpsons[0] # print element 0 ('homer')<br />len(simpsons) # returns the length (3)</p>
<p># modify a list (does not return the list)<br />simpsons.append('lisa') # append element to end<br />simpsons.extend(['itchy', 'scratchy']) # append multiple elements to end<br />simpsons.insert(0, 'maggie') # insert element at index 0 (shifts everything right)<br />simpsons.remove('bart') # searches for first instance and removes it<br />simpsons.pop(0) # removes element 0 and returns it<br />del simpsons[0] # removes element 0 (does not return it)<br />simpsons[0] = 'krusty' # replace element 0</p>
<p># concatenate lists (slower than 'extend' method)<br />neighbors = simpsons + ['ned','rod','todd']</p>
<p># find elements in a list<br />simpsons.count('lisa') # counts the number of instances<br />simpsons.index('itchy') # returns index of first instance</p>
<p># list slicing [start:end:stride]<br />weekdays = ['mon','tues','wed','thurs','fri']<br />weekdays[0] # element 0<br />weekdays[0:3] # elements 0, 1, 2<br />weekdays[:3] # elements 0, 1, 2<br />weekdays[3:] # elements 3, 4<br />weekdays[-1] # last element (element 4)<br />weekdays[::2] # every 2nd element (0, 2, 4)<br />weekdays[::-1] # backwards (4, 3, 2, 1, 0)</p>
<p># alternative method for returning the list backwards<br />list(reversed(weekdays))</p>
<p># sort a list in place (modifies but does not return the list)<br />simpsons.sort()<br />simpsons.sort(reverse=True) # sort in reverse<br />simpsons.sort(key=len) # sort by a key</p>
<p># return a sorted list (but does not modify the original list)<br />sorted(simpsons)<br />sorted(simpsons, reverse=True)<br />sorted(simpsons, key=len)</p>
<p># insert into an already sorted list, and keep it sorted<br />num = [10, 20, 40, 50]<br />from bisect import insort<br />insort(num, 30)</p>
<p># create a second reference to the same list<br />same_num = num<br />same_num[0] = 0 # modifies both 'num' and 'same_num'</p>
<p># copy a list (two ways)<br />new_num = num[:]<br />new_num = list(num)</p>
<p># examine objects<br />id(num) == id(same_num) # returns True<br />id(num) == id(new_num) # returns False<br />num is same_num # returns True<br />num is new_num # returns False<br />num == same_num # returns True<br />num == new_num # returns True (their contents are equivalent)</p>
<p><br />### TUPLES ###<br />## like lists, but they don't change size<br />## properties: ordered, iterable, immutable, can contain multiple data types</p>
<p># create a tuple<br />digits = (0, 1, 'two') # create a tuple directly<br />digits = tuple([0, 1, 'two']) # create a tuple from a list<br />zero = (0,) # trailing comma is required to indicate it's a tuple</p>
<p># examine a tuple<br />digits[2] # returns 'two'<br />len(digits) # returns 3<br />digits.count(0) # counts the number of instances of that value (1)<br />digits.index(1) # returns the index of the first instance of that value (1)</p>
<p># elements of a tuple cannot be modified<br />#digits[2] = 2 # throws an error</p>
<p># concatenate tuples<br />digits = digits + (3, 4)</p>
<p># create a single tuple with elements repeated (also works with lists)<br />(3, 4) * 2 # returns (3, 4, 3, 4)</p>
<p># sort a list of tuples<br />tens = [(20, 60), (10, 40), (20, 30)]<br />sorted(tens) # sorts by first element in tuple, then second element<br /> # returns [(10, 40), (20, 30), (20, 60)]</p>
<p># tuple unpacking<br />bart = ('male', 10, 'simpson') # create a tuple<br />(sex, age, surname) = bart # assign three values at once</p>
<p><br />### STRINGS ###<br />## properties: iterable, immutable<br /># create a string<br />s = str(42) # convert another data type into a string<br />s = 'I like you'</p>
<p># examine a string<br />s[0] # returns 'I'<br />len(s) # returns 10</p>
<p># string slicing like lists<br />s[:6] # returns 'I like'<br />s[7:] # returns 'you'<br />s[-1] # returns 'u'</p>
<p># basic string methods (does not modify the original string)<br />s.lower() # returns 'i like you'<br />s.upper() # returns 'I LIKE YOU'<br />s.startswith('I') # returns True<br />s.endswith('you') # returns True<br />s.isdigit() # returns False (returns True if every character in the string is a digit)<br />s.find('like') # returns index of first occurrence (2), but doesn't support regex<br />s.find('hate') # returns -1 since not found<br />s.replace('like','love') # replaces all instances of 'like' with 'love'</p>
<p># split a string into a list of substrings separated by a delimiter<br />s.split(' ') # returns ['I','like','you']<br />s.split() # same thing<br />s2 = 'a, an, the'<br />s2.split(',') # returns ['a',' an',' the']</p>
<p># join a list of strings into one string using a delimiter<br />stooges = ['larry','curly','moe']<br />' '.join(stooges) # returns 'larry curly moe'</p>
<p># concatenate strings<br />s3 = 'The meaning of life is'<br />s4 = '42'<br />s3 + ' ' + s4 # returns 'The meaning of life is 42'<br />s3 + ' ' + str(42) # same thing</p>
<p># remove whitespace from start and end of a string<br />s5 = ' ham and cheese '<br />s5.strip() # returns 'ham and cheese'</p>
<p># string substitutions: all of these return 'raining cats and dogs'<br />'raining %s and %s' % ('cats','dogs') # old way<br />'raining {} and {}'.format('cats','dogs') # new way<br />'raining {arg1} and {arg2}'.format(arg1='cats',arg2='dogs') # named arguments</p>
<p># string formatting<br /># more examples: http://mkaz.com/2012/10/10/python-string-format/<br />'pi is {:.2f}'.format(3.14159) # returns 'pi is 3.14'</p>
<p># normal strings versus raw strings<br />print 'first line\nsecond line' # normal strings allow for escaped characters<br />print r'first line\nfirst line' # raw strings treat backslashes as literal characters</p>
<p><br />### DICTIONARIES ###<br />## properties: unordered, iterable, mutable, can contain multiple data types<br />## made up of key-value pairs<br />## keys must be unique, and can be strings, numbers, or tuples<br />## values can be any type</p>
<p># create an empty dictionary (two ways)<br />empty_dict = {}<br />empty_dict = dict()</p>
<p># create a dictionary (two ways)<br />family = {'dad':'homer', 'mom':'marge', 'size':6}<br />family = dict(dad='homer', mom='marge', size=6)</p>
<p># convert a list of tuples into a dictionary<br />list_of_tuples = [('dad','homer'), ('mom','marge'), ('size', 6)]<br />family = dict(list_of_tuples)</p>
<p># examine a dictionary<br />family['dad'] # returns 'homer'<br />len(family) # returns 3<br />family.keys() # returns list: ['dad', 'mom', 'size']<br />family.values() # returns list: ['homer', 'marge', 6]<br />family.items() # returns list of tuples:<br /> # [('dad', 'homer'), ('mom', 'marge'), ('size', 6)]<br />'mom' in family # returns True<br />'marge' in family # returns False (only checks keys)</p>
<p># modify a dictionary (does not return the dictionary)<br />family['cat'] = 'snowball' # add a new entry<br />family['cat'] = 'snowball ii' # edit an existing entry<br />del family['cat'] # delete an entry<br />family['kids'] = ['bart', 'lisa'] # value can be a list<br />family.pop('dad') # removes an entry and returns the value ('homer')<br />family.update({'baby':'maggie', 'grandpa':'abe'}) # add multiple entries</p>
<p># accessing values more safely with 'get'<br />family['mom'] # returns 'marge'<br />family.get('mom') # same thing<br />#family['grandma'] # throws an error<br />family.get('grandma') # returns None<br />family.get('grandma', 'not found') # returns 'not found' (the default)</p>
<p># accessing a list element within a dictionary<br />family['kids'][0] # returns 'bart'<br />family['kids'].remove('lisa') # removes 'lisa'</p>
<p># string substitution using a dictionary<br />'youngest child is %(baby)s' % family # returns 'youngest child is maggie'</p>
<p><br />### SETS ###<br />## like dictionaries, but with keys only (no values)<br />## properties: unordered, iterable, mutable, can contain multiple data types<br />## made up of unique elements (strings, numbers, or tuples)</p>
<p># create an empty set<br />empty_set = set()</p>
<p># create a set<br />languages = {'python', 'r', 'java'} # create a set directly<br />snakes = set(['cobra', 'viper', 'python']) # create a set from a list</p>
<p># examine a set<br />len(languages) # returns 3<br />'python' in languages # returns True</p>
<p># set operations<br />languages &amp; snakes # returns intersection: {'python'}<br />languages | snakes # returns union: {'cobra', 'r', 'java', 'viper', 'python'}<br />languages - snakes # returns set difference: {'r', 'java'}<br />snakes - languages # returns set difference: {'cobra', 'viper'}</p>
<p># modify a set (does not return the set)<br />languages.add('sql') # add a new element<br />languages.add('r') # try to add an existing element (ignored, no error)<br />languages.remove('java') # remove an element<br />#languages.remove('c') # try to remove a non-existing element (throws an error)<br />languages.discard('c') # removes an element if present, but ignored otherwise<br />languages.pop() # removes and returns an arbitrary element<br />languages.clear() # removes all elements<br />languages.update('go', 'spark') # add multiple elements (can also pass a list or set)</p>
<p># get a sorted list of unique elements from a list<br />sorted(set([9, 0, 2, 1, 0])) # returns [0, 1, 2, 9]</p>
<p><br />### DEFINING FUNCTIONS ###<br /># define a function with no arguments and no return values<br />def print_text():<br /> print 'this is text'</p>
<p># call the function<br />print_text()</p>
<p># define a function with one argument and no return values<br />def print_this(x):<br /> print x</p>
<p># call the function<br />print_this(3) # prints 3<br />n = print_this(3) # prints 3, but doesn't assign 3 to n<br /> # because the function has no return statement</p>
<p># define a function with one argument and one return value<br />def square_this(x):<br /> return x**2</p>
<p># include an optional docstring to describe the effect of a function<br />def square_this(x):<br /> " ""Return the square of a number. "" "<br /> return x**2</p>
<p># call the function<br />square_this(3) # prints 9<br />var = square_this(3) # assigns 9 to var, but does not print 9</p>
<p># define a function with two 'positional arguments' (no default values) and<br /># one 'keyword argument' (has a default value)<br />def calc(a, b, op='add'):<br /> if op == 'add':<br /> return a + b<br /> elif op == 'sub':<br /> return a - b<br /> else:<br /> print 'valid operations are add and sub'</p>
<p># call the function<br />calc(10, 4, op='add') # returns 14<br />calc(10, 4, 'add') # also returns 14: unnamed arguments are inferred by position<br />calc(10, 4) # also returns 14: default for 'op' is 'add'<br />calc(10, 4, 'sub') # returns 6<br />calc(10, 4, 'div') # prints 'valid operations are add and sub'</p>
<p># use 'pass' as a placeholder if you haven't written the function body<br />def stub():<br /> pass</p>
<p># return two values from a single function<br />def min_max(nums):<br /> return min(nums), max(nums)</p>
<p># return values can be assigned to a single variable as a tuple<br />nums = [1, 2, 3]<br />min_max_num = min_max(nums) # min_max_num = (1, 3)</p>
<p># return values can be assigned into multiple variables using tuple unpacking<br />min_num, max_num = min_max(nums) # min_num = 1, max_num = 3</p>
<p><br />### ANONYMOUS (LAMBDA) FUNCTIONS ###<br />## primarily used to temporarily define a function for use by another function<br /># define a function the "usual " way<br />def squared(x):<br /> return x**2</p>
<p># define an identical function using lambda<br />squared = lambda x: x**2</p>
<p># sort a list of strings by the last letter (without using lambda)<br />simpsons = ['homer', 'marge', 'bart']<br />def last_letter(word):<br /> return word[-1]<br />sorted(simpsons, key=last_letter)</p>
<p># sort a list of strings by the last letter (using lambda)<br />sorted(simpsons, key=lambda word: word[-1])</p>
<p><br />### FOR LOOPS AND WHILE LOOPS ###<br /># range returns a list of integers<br />range(0, 3) # returns [0, 1, 2]: includes first value but excludes second value<br />range(3) # same thing: starting at zero is the default<br />range(0, 5, 2) # returns [0, 2, 4]: third argument specifies the 'stride'</p>
<p># for loop (not recommended)<br />fruits = ['apple', 'banana', 'cherry']<br />for i in range(len(fruits)):<br /> print fruits[i].upper()</p>
<p># alternative for loop (recommended style)<br />for fruit in fruits:<br /> print fruit.upper()</p>
<p># use xrange when iterating over a large sequence to avoid actually creating the integer list in memory<br />for i in xrange(10**6):<br /> pass</p>
<p># iterate through two things at once (using tuple unpacking)<br />family = {'dad':'homer', 'mom':'marge', 'size':6}<br />for key, value in family.items():<br /> print key, value</p>
<p># use enumerate if you need to access the index value within the loop<br />for index, fruit in enumerate(fruits):<br /> print index, fruit</p>
<p># for/else loop<br />for fruit in fruits:<br /> if fruit == 'banana':<br /> print "Found the banana! "<br /> break # exit the loop and skip the 'else' block<br />else:<br /> # this block executes ONLY if the for loop completes without hitting 'break'<br /> print "Can 't find the banana"</p>
<p># while loop<br />count = 0<br />while count &lt; 5:<br /> print "This will print 5 times"<br /> count += 1 # equivalent to 'count=c ount + 1 '</p>
<p><br />### COMPREHENSIONS ###<br /># for loop to create a list of cubes<br />nums = [1, 2, 3, 4, 5]<br />cubes = []<br />for num in nums:<br /> cubes.append(num**3)</p>
<p># equivalent list comprehension<br />cubes = [num**3 for num in nums] # [1, 8, 27, 64, 125]</p>
<p># for loop to create a list of cubes of even numbers<br />cubes_of_even = []<br />for num in nums:<br /> if num % 2 == 0:<br /> cubes_of_even.append(num**3)</p>
<p># equivalent list comprehension<br /># syntax: [expression for variable in iterable if condition]<br />cubes_of_even = [num**3 for num in nums if num % 2 == 0] # [8, 64]</p>
<p># for loop to cube even numbers and square odd numbers<br />cubes_and_squares = []<br />for num in nums:<br /> if num % 2 == 0:<br /> cubes_and_squares.append(num**3)<br /> else:<br /> cubes_and_squares.append(num**2)</p>
<p># equivalent list comprehension (using a ternary expression)<br /># syntax: [true_condition if condition else false_condition for variable in iterable]<br />cubes_and_squares = [num**3 if num % 2 == 0 else num**2 for num in nums] # [1, 8, 9, 64, 25]</p>
<p># for loop to flatten a 2d-matrix<br />matrix = [[1, 2], [3, 4]]<br />items = []<br />for row in matrix:<br /> for item in row:<br /> items.append(item)</p>
<p># equivalent list comprehension<br />items = [item for row in matrix<br /> for item in row] # [1, 2, 3, 4]</p>
<p># set comprehension<br />fruits = ['apple ', 'banana ', 'cherry ']<br />unique_lengths = {len(fruit) for fruit in fruits} # {5, 6}</p>
<p># dictionary comprehension<br />fruit_lengths = {fruit:len(fruit) for fruit in fruits} # {'apple ': 5, 'banana ': 6, 'cherry ': 6}<br />fruit_indices = {fruit:index for index, fruit in enumerate(fruits)} # {'apple ': 0, 'banana ': 1, 'cherry ': 2}</p>
<p><br />### MAP, REDUCE, FILTER ###<br /># 'map ' applies a function to every element of a sequence and returns a list<br />simpsons = ['homer ', 'marge ', 'bart ']<br />map(len, simpsons) # returns [5, 5, 4]<br />map(lambda word: word[-1], simpsons) # returns ['r ', 'e ', 't ']</p>
<p># equivalent list comprehensions<br />[len(word) for word in simpsons]<br />[word[-1] for word in simpsons]</p>
<p># 'reduce ' applies a binary function to the first two elements of a sequence,<br /># then repeats with the result and the next element, through the end of the sequence<br />reduce(lambda x, y: x + y, range(4)) # (((0+1)+2)+3) = 6</p>
<p># 'filter ' returns a sequence containing the items from the original sequence<br /># for which the condition is True<br />filter(lambda x: x % 2 == 0, range(5)) # returns [0, 2, 4]</p>
</body>
</pre>

</html>
